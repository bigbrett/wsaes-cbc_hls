

================================================================
== Vivado HLS Report for 'aes_mixColumns_inv'
================================================================
* Date:           Thu Jun  8 09:29:41 2017

* Version:        2016.4 (Build 1756540 on Mon Jan 23 19:31:01 MST 2017)
* Project:        aescbc
* Solution:       solution1
* Product family: zynq
* Target device:  xc7z020clg484-1


================================================================
== Performance Estimates
================================================================
+ Timing (ns): 
    * Summary: 
    +--------+-------+----------+------------+
    |  Clock | Target| Estimated| Uncertainty|
    +--------+-------+----------+------------+
    |ap_clk  |   8.00|      5.48|        1.00|
    +--------+-------+----------+------------+

+ Latency (clock cycles): 
    * Summary: 
    +-----+-----+-----+-----+---------+
    |  Latency  |  Interval | Pipeline|
    | min | max | min | max |   Type  |
    +-----+-----+-----+-----+---------+
    |   25|   25|   25|   25|   none  |
    +-----+-----+-----+-----+---------+

    + Detail: 
        * Instance: 
        N/A

        * Loop: 
        +----------+-----+-----+----------+-----------+-----------+------+----------+
        |          |  Latency  | Iteration|  Initiation Interval  | Trip |          |
        | Loop Name| min | max |  Latency |  achieved |   target  | Count| Pipelined|
        +----------+-----+-----+----------+-----------+-----------+------+----------+
        |- Loop 1  |   24|   24|         6|          -|          -|     4|    no    |
        +----------+-----+-----+----------+-----------+-----------+------+----------+

============================================================
+ Verbose Summary: Synthesis Manager
============================================================
InlineROM: 1
ExposeGlobal: 0
============================================================
+ Verbose Summary: CDFG Model
============================================================
IsTopModel: 0
ResetActiveHigh: 1
IsCombinational: 0
IsDatapathOnly: 0
HasWiredReturn: 1
HasMFsm: 0
HasVarLatency: 1
IsPipeline: 0
IsRtlPipelined: 0
IsInstanceOverlapped: 0
IsDontTouch: 0
HasImplIP: 0
IsGatedGlobalClock: 0


============================================================
+ Verbose Summary: Schedule
============================================================
* Number of FSM states: 7
* Pipeline: 0
* Dataflow Pipeline: 0

* FSM state transitions: 
1 --> 
	2  / true
2 --> 
	3  / (!tmp)
3 --> 
	4  / true
4 --> 
	5  / true
5 --> 
	6  / true
6 --> 
	7  / true
7 --> 
	2  / true
* FSM state operations: 

 <State 1>: 1.57ns
ST_1: StgValue_8 (2)  [1/1] 1.57ns  loc: aescbc/src/aesecb.c:274
:0  br label %1


 <State 2>: 2.39ns
ST_2: i (4)  [1/1] 0.00ns
:0  %i = phi i5 [ 0, %0 ], [ %i_31, %2 ]

ST_2: tmp (5)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:274
:1  %tmp = call i1 @_ssdm_op_BitSelect.i1.i5.i32(i5 %i, i32 4)

ST_2: empty (6)  [1/1] 0.00ns
:2  %empty = call i32 (...)* @_ssdm_op_SpecLoopTripCount(i64 4, i64 4, i64 4)

ST_2: StgValue_12 (7)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:274
:3  br i1 %tmp, label %3, label %2

ST_2: tmp_s (9)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:276
:0  %tmp_s = zext i5 %i to i64

ST_2: buf_addr (10)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:276
:1  %buf_addr = getelementptr [16 x i8]* %buf_r, i64 0, i64 %tmp_s

ST_2: a (11)  [2/2] 2.39ns  loc: aescbc/src/aesecb.c:276
:2  %a = load i8* %buf_addr, align 1

ST_2: tmp_1 (12)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:277
:3  %tmp_1 = trunc i5 %i to i4

ST_2: tmp_32 (13)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:277
:4  %tmp_32 = or i4 %tmp_1, 1

ST_2: tmp_33 (14)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:277
:5  %tmp_33 = zext i4 %tmp_32 to i64

ST_2: buf_addr_8 (15)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:277
:6  %buf_addr_8 = getelementptr [16 x i8]* %buf_r, i64 0, i64 %tmp_33

ST_2: b (16)  [2/2] 2.39ns  loc: aescbc/src/aesecb.c:277
:7  %b = load i8* %buf_addr_8, align 1

ST_2: i_31 (85)  [1/1] 1.72ns  loc: aescbc/src/aesecb.c:274
:76  %i_31 = add i5 4, %i

ST_2: StgValue_22 (88)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:289
:0  ret void


 <State 3>: 2.39ns
ST_3: a (11)  [1/2] 2.39ns  loc: aescbc/src/aesecb.c:276
:2  %a = load i8* %buf_addr, align 1

ST_3: b (16)  [1/2] 2.39ns  loc: aescbc/src/aesecb.c:277
:7  %b = load i8* %buf_addr_8, align 1

ST_3: tmp_34 (17)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:278
:8  %tmp_34 = or i4 %tmp_1, 2

ST_3: tmp_35 (18)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:278
:9  %tmp_35 = zext i4 %tmp_34 to i64

ST_3: buf_addr_9 (19)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:278
:10  %buf_addr_9 = getelementptr [16 x i8]* %buf_r, i64 0, i64 %tmp_35

ST_3: c (20)  [2/2] 2.39ns  loc: aescbc/src/aesecb.c:278
:11  %c = load i8* %buf_addr_9, align 1

ST_3: tmp_36 (21)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:279
:12  %tmp_36 = or i4 %tmp_1, 3

ST_3: tmp_37 (22)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:279
:13  %tmp_37 = zext i4 %tmp_36 to i64

ST_3: buf_addr_10 (23)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:279
:14  %buf_addr_10 = getelementptr [16 x i8]* %buf_r, i64 0, i64 %tmp_37

ST_3: d (24)  [2/2] 2.39ns  loc: aescbc/src/aesecb.c:279
:15  %d = load i8* %buf_addr_10, align 1


 <State 4>: 5.13ns
ST_4: c (20)  [1/2] 2.39ns  loc: aescbc/src/aesecb.c:278
:11  %c = load i8* %buf_addr_9, align 1

ST_4: d (24)  [1/2] 2.39ns  loc: aescbc/src/aesecb.c:279
:15  %d = load i8* %buf_addr_10, align 1

ST_4: x_assign_5 (25)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:280
:16  %x_assign_5 = xor i8 %b, %a

ST_4: tmp1 (26)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:280 (grouped into LUT with out node e)
:17  %tmp1 = xor i8 %d, %x_assign_5

ST_4: e (27)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:280 (out node of the LUT)
:18  %e = xor i8 %tmp1, %c

ST_4: y_1 (28)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:281
:19  %y_1 = shl i8 %e, 1

ST_4: tmp_3 (29)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:281 (grouped into LUT with out node y_19)
:20  %tmp_3 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %e, i32 7)

ST_4: tmp_1_i (30)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:281 (grouped into LUT with out node y_19)
:21  %tmp_1_i = xor i8 %y_1, 27

ST_4: y_19 (31)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:281 (out node of the LUT)
:22  %y_19 = select i1 %tmp_3, i8 %tmp_1_i, i8 %y_1


 <State 5>: 5.48ns
ST_5: tmp2 (32)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:282 (grouped into LUT with out node x_assign_1)
:23  %tmp2 = xor i8 %a, %y_19

ST_5: x_assign_1 (33)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:282 (out node of the LUT)
:24  %x_assign_1 = xor i8 %tmp2, %c

ST_5: y_3 (34)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:282
:25  %y_3 = shl i8 %x_assign_1, 1

ST_5: tmp_5 (35)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:282 (grouped into LUT with out node y_4)
:26  %tmp_5 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %x_assign_1, i32 7)

ST_5: tmp_1_i1 (36)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:282 (grouped into LUT with out node y_4)
:27  %tmp_1_i1 = xor i8 %y_3, 27

ST_5: y_4 (37)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:282 (out node of the LUT)
:28  %y_4 = select i1 %tmp_5, i8 %tmp_1_i1, i8 %y_3

ST_5: y_5 (38)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:282
:29  %y_5 = shl i8 %y_4, 1

ST_5: tmp_7 (39)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:282 (grouped into LUT with out node x)
:30  %tmp_7 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %y_4, i32 7)

ST_5: tmp_1_i2 (40)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:282 (grouped into LUT with out node x)
:31  %tmp_1_i2 = xor i8 %y_5, 27

ST_5: y_6 (41)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:282 (grouped into LUT with out node x)
:32  %y_6 = select i1 %tmp_7, i8 %tmp_1_i2, i8 %y_5

ST_5: x (42)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:282 (out node of the LUT)
:33  %x = xor i8 %y_6, %e

ST_5: tmp3 (43)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:283 (grouped into LUT with out node x_assign_3)
:34  %tmp3 = xor i8 %b, %y_19

ST_5: x_assign_3 (44)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:283 (out node of the LUT)
:35  %x_assign_3 = xor i8 %tmp3, %d

ST_5: y_7 (45)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:283
:36  %y_7 = shl i8 %x_assign_3, 1

ST_5: tmp_9 (46)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:283 (grouped into LUT with out node y_8)
:37  %tmp_9 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %x_assign_3, i32 7)

ST_5: tmp_1_i3 (47)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:283 (grouped into LUT with out node y_8)
:38  %tmp_1_i3 = xor i8 %y_7, 27

ST_5: y_8 (48)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:283 (out node of the LUT)
:39  %y_8 = select i1 %tmp_9, i8 %tmp_1_i3, i8 %y_7

ST_5: y_9 (49)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:283
:40  %y_9 = shl i8 %y_8, 1

ST_5: tmp_11 (50)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:283 (grouped into LUT with out node y)
:41  %tmp_11 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %y_8, i32 7)

ST_5: tmp_1_i4 (51)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:283 (grouped into LUT with out node y)
:42  %tmp_1_i4 = xor i8 %y_9, 27

ST_5: y_10 (52)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:283 (grouped into LUT with out node y)
:43  %y_10 = select i1 %tmp_11, i8 %tmp_1_i4, i8 %y_9

ST_5: y (53)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:283 (out node of the LUT)
:44  %y = xor i8 %y_10, %e

ST_5: y_11 (54)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:284
:45  %y_11 = shl i8 %x_assign_5, 1

ST_5: tmp_13 (55)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:284 (grouped into LUT with out node tmp_38)
:46  %tmp_13 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %x_assign_5, i32 7)

ST_5: tmp_1_i5 (56)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:284 (grouped into LUT with out node tmp_38)
:47  %tmp_1_i5 = xor i8 %y_11, 27

ST_5: y_12 (57)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:284 (grouped into LUT with out node tmp_38)
:48  %y_12 = select i1 %tmp_13, i8 %tmp_1_i5, i8 %y_11

ST_5: tmp4 (58)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:284 (grouped into LUT with out node tmp_38)
:49  %tmp4 = xor i8 %y_12, %x

ST_5: tmp_38 (59)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:284 (out node of the LUT)
:50  %tmp_38 = xor i8 %tmp4, %a

ST_5: x_assign_6 (61)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:285
:52  %x_assign_6 = xor i8 %c, %b

ST_5: y_13 (62)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:285
:53  %y_13 = shl i8 %x_assign_6, 1

ST_5: tmp_15 (63)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:285 (grouped into LUT with out node tmp_39)
:54  %tmp_15 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %x_assign_6, i32 7)

ST_5: tmp_1_i6 (64)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:285 (grouped into LUT with out node tmp_39)
:55  %tmp_1_i6 = xor i8 %y_13, 27

ST_5: y_14 (65)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:285 (grouped into LUT with out node tmp_39)
:56  %y_14 = select i1 %tmp_15, i8 %tmp_1_i6, i8 %y_13

ST_5: tmp5 (66)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:285 (grouped into LUT with out node tmp_39)
:57  %tmp5 = xor i8 %y_14, %y

ST_5: tmp_39 (67)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:285 (out node of the LUT)
:58  %tmp_39 = xor i8 %tmp5, %b

ST_5: x_assign_7 (69)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:286
:60  %x_assign_7 = xor i8 %d, %c

ST_5: y_15 (70)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:286
:61  %y_15 = shl i8 %x_assign_7, 1

ST_5: tmp_17 (71)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:286 (grouped into LUT with out node tmp_40)
:62  %tmp_17 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %x_assign_7, i32 7)

ST_5: tmp_1_i7 (72)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:286 (grouped into LUT with out node tmp_40)
:63  %tmp_1_i7 = xor i8 %y_15, 27

ST_5: y_16 (73)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:286 (grouped into LUT with out node tmp_40)
:64  %y_16 = select i1 %tmp_17, i8 %tmp_1_i7, i8 %y_15

ST_5: tmp6 (74)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:286 (grouped into LUT with out node tmp_40)
:65  %tmp6 = xor i8 %y_16, %x

ST_5: tmp_40 (75)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:286 (out node of the LUT)
:66  %tmp_40 = xor i8 %tmp6, %c

ST_5: x_assign_8 (77)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:287
:68  %x_assign_8 = xor i8 %d, %a

ST_5: y_17 (78)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:287
:69  %y_17 = shl i8 %x_assign_8, 1

ST_5: tmp_19 (79)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:287 (grouped into LUT with out node tmp_41)
:70  %tmp_19 = call i1 @_ssdm_op_BitSelect.i1.i8.i32(i8 %x_assign_8, i32 7)

ST_5: tmp_1_i8 (80)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:287 (grouped into LUT with out node tmp_41)
:71  %tmp_1_i8 = xor i8 %y_17, 27

ST_5: y_18 (81)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:287 (grouped into LUT with out node tmp_41)
:72  %y_18 = select i1 %tmp_19, i8 %tmp_1_i8, i8 %y_17

ST_5: tmp7 (82)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:287 (grouped into LUT with out node tmp_41)
:73  %tmp7 = xor i8 %y_18, %y

ST_5: tmp_41 (83)  [1/1] 1.37ns  loc: aescbc/src/aesecb.c:287 (out node of the LUT)
:74  %tmp_41 = xor i8 %tmp7, %d


 <State 6>: 2.39ns
ST_6: StgValue_91 (60)  [1/1] 2.39ns  loc: aescbc/src/aesecb.c:284
:51  store i8 %tmp_38, i8* %buf_addr, align 1

ST_6: StgValue_92 (68)  [1/1] 2.39ns  loc: aescbc/src/aesecb.c:285
:59  store i8 %tmp_39, i8* %buf_addr_8, align 1


 <State 7>: 2.39ns
ST_7: StgValue_93 (76)  [1/1] 2.39ns  loc: aescbc/src/aesecb.c:286
:67  store i8 %tmp_40, i8* %buf_addr_9, align 1

ST_7: StgValue_94 (84)  [1/1] 2.39ns  loc: aescbc/src/aesecb.c:287
:75  store i8 %tmp_41, i8* %buf_addr_10, align 1

ST_7: StgValue_95 (86)  [1/1] 0.00ns  loc: aescbc/src/aesecb.c:274
:77  br label %1



============================================================
+ Verbose Summary: Timing violations
============================================================
Target clock period: 8ns, clock uncertainty: 1ns.

 <State 1>: 1.57ns
The critical path consists of the following:
	multiplexor before 'phi' operation ('i') with incoming values : ('i', aescbc/src/aesecb.c:274) [4]  (1.57 ns)

 <State 2>: 2.39ns
The critical path consists of the following:
	'phi' operation ('i') with incoming values : ('i', aescbc/src/aesecb.c:274) [4]  (0 ns)
	'getelementptr' operation ('buf_addr', aescbc/src/aesecb.c:276) [10]  (0 ns)
	'load' operation ('a', aescbc/src/aesecb.c:276) on array 'buf_r' [11]  (2.39 ns)

 <State 3>: 2.39ns
The critical path consists of the following:
	'load' operation ('a', aescbc/src/aesecb.c:276) on array 'buf_r' [11]  (2.39 ns)

 <State 4>: 5.13ns
The critical path consists of the following:
	'load' operation ('c', aescbc/src/aesecb.c:278) on array 'buf_r' [20]  (2.39 ns)
	'xor' operation ('e', aescbc/src/aesecb.c:280) [27]  (1.37 ns)
	'shl' operation ('y', aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:281) [28]  (0 ns)
	'select' operation ('y', aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:281) [31]  (1.37 ns)

 <State 5>: 5.48ns
The critical path consists of the following:
	'xor' operation ('tmp2', aescbc/src/aesecb.c:282) [32]  (0 ns)
	'xor' operation ('x', aescbc/src/aesecb.c:282) [33]  (1.37 ns)
	'shl' operation ('y', aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:282) [34]  (0 ns)
	'select' operation ('y', aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:282) [37]  (1.37 ns)
	'shl' operation ('y', aescbc/src/aesecb.c:189->aescbc/src/aesecb.c:282) [38]  (0 ns)
	'select' operation ('y', aescbc/src/aesecb.c:190->aescbc/src/aesecb.c:282) [41]  (0 ns)
	'xor' operation ('x', aescbc/src/aesecb.c:282) [42]  (1.37 ns)
	'xor' operation ('tmp4', aescbc/src/aesecb.c:284) [58]  (0 ns)
	'xor' operation ('tmp_38', aescbc/src/aesecb.c:284) [59]  (1.37 ns)

 <State 6>: 2.39ns
The critical path consists of the following:
	'store' operation (aescbc/src/aesecb.c:284) of variable 'tmp_38', aescbc/src/aesecb.c:284 on array 'buf_r' [60]  (2.39 ns)

 <State 7>: 2.39ns
The critical path consists of the following:
	'store' operation (aescbc/src/aesecb.c:286) of variable 'tmp_40', aescbc/src/aesecb.c:286 on array 'buf_r' [76]  (2.39 ns)


============================================================
+ Verbose Summary: Binding
============================================================
N/A
* FSMD analyzer results:
  - Output states:
 - Input state : 
  - Chain level:
	State 1
	State 2
	State 3
	State 4
	State 5
	State 6
	State 7


============================================================
+ Verbose Summary: Datapath Resource usage 
============================================================
N/A
